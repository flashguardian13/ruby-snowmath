/*
Maths bindings for Ruby
Written by Noel Cower

See COPYING for license information
*/

#include "maths_local.h"
#include "ruby.h"

/*
  Generates a label within the current function with the given name. Should be
  as unique as anyone needs.
*/
#define SM_LABEL(NAME) __FUNCTION__##NAME

/*
  Returns the Ruby class value's identifier
*/
#define SM_KLASS(TYPE)              s_sm_##TYPE##_klass

/*
  Returns the wrap identifier for a given type. Only useful in functions
  generated by macros. The wrapping function will always be sm_wrap_TYPE.
*/
#define SM_WRAP(TYPE)               sm_wrap_##TYPE

/*
  Same as SM_WRAP but for unwrapping. Will always be sm_unwrap_TYPE
*/
#define SM_UNWRAP(TYPE)             sm_unwrap_##TYPE

/*
  Defines the static class value for a type.
*/
#define DEF_SM_TYPE_KLASS(TYPE)     static VALUE SM_KLASS(TYPE) = Qnil

/*
  Returns whether a given ruby value is a kind of RB_TYPE (a Ruby value for a
  class).
*/
#define SM_RB_IS_A(RB_VALUE, RB_TYPE) (RTEST(rb_obj_is_kind_of((RB_VALUE), (RB_TYPE))))

/*
  Wrapper around SM_RB_IS_A that checks for SM_RB_IS_A(value, SM_KLASS(type)).
  Vaguely convenient.
*/
#define SM_IS_A(SM_VALUE, SM_TYPE)  SM_RB_IS_A(SM_VALUE, SM_KLASS(SM_TYPE))

/*
  Convenience macro to raise an exception if a value isn't of a given type. Only
  useful for a few things, as vec3, vec4, and quat are semi-compatible due to
  having similar sizes. So any vec4/quat can be used as a vec3 in some cases and
  any quat can be used in place of a vec4 except in the case of a few binary ops
  and such (because the binary op macro doesn't check for much -- so that might
  need rewriting later).
*/
#define SM_RAISE_IF_NOT_TYPE(SM_VALUE, SM_TYPE) do {                                              \
  if (!SM_IS_A(SM_VALUE, SM_TYPE)) {                                                              \
    rb_raise(rb_eTypeError, "Expected %s, got %s",                                                \
      rb_class2name(SM_KLASS(SM_TYPE)),                                                           \
      rb_obj_classname((SM_VALUE)));                                                              \
  } } while (0)

/* Declares the wrap function for a type. */
#define DECL_SM_WRAP_OP(TYPE)                                                                     \
static VALUE SM_WRAP(TYPE) (const TYPE##_t value, VALUE klass)

/* Declares the unwrap function for a type. */
#define DECL_SM_UNWRAP_OP(TYPE)                                                                   \
static TYPE##_t * SM_UNWRAP(TYPE) (VALUE sm_value, TYPE##_t store)


/*
  Note about generated wrap / unwrap functions:
  Neither function actually cares about its input. It will not verify that a
  quat is passed to sm_unwrap_quat and you can similarly pass a vec4 to
  sm_wrap_vec3 or sm_wrap_quat, so the types are mostly interchangeable provided
  they're of the same size.

  This allows some flexibility when passing Quats to Vec4 functions and so on,
  though it's a better idea to simply create a new Vec4 or Quat when you need to
  pass one to another's function. The conversion is easy enough, so it's not a
  huge deal.
*/

/* Defines the wrap function for a type. */
#define DEF_SM_WRAP_OP(TYPE)                                                                      \
DECL_SM_WRAP_OP(TYPE)                                                                             \
{                                                                                                 \
  TYPE##_t *copy;                                                                                 \
  VALUE sm_wrapped = Qnil;                                                                        \
  if (!RTEST(klass)) {                                                                            \
    klass = SM_KLASS(TYPE);                                                                       \
  }                                                                                               \
  sm_wrapped = Data_Make_Struct(klass, TYPE##_t, 0, free, copy);                                  \
  if (value) {                                                                                    \
    TYPE##_copy(value, *copy);                                                                    \
  }                                                                                               \
  return sm_wrapped;                                                                              \
}

/* Defines the unwrap function for a type. */
#define DEF_SM_UNWRAP_OP(TYPE)                                                                    \
DECL_SM_UNWRAP_OP(TYPE)                                                                           \
{                                                                                                 \
  TYPE##_t *value;                                                                                \
  Data_Get_Struct(sm_value, TYPE##_t, value);                                                     \
  if(store) TYPE##_copy(*value, store);                                                           \
  return value;                                                                                   \
}

/*
  Defines a binary op for a given type (defined as
  TYPE_FUNC(input_rhs, input_lhs, output) where input_rhs is self, input_lhs
  is an arbitrary value, and output is either nil or a value of OTYPE to store
  the result of the op in).

  Binary ops are strict about the input/output types. You cannot pass a vec4 to
  a quat function and vice versa. This is slightly contrary to other functions
  that are hand-written for the type because I obviously know more about the
  input than I do in the case of a macro-generated function. In the future, I'll
  probably replace all generated functions with hand-written ones, but in the
  meantime, just be aware that you can get exceptions for otherwise compatible
  types.

  By default, if no output object is provided, a new one is created and
  returned. If an output object is provided, it is returned.
*/
#define DEF_SM_BINARY_OP(FUNC, TYPE, RHSTYPE, OTYPE)                                              \
static VALUE sm_##TYPE##_##FUNC (int argc, VALUE *argv, VALUE sm_self)                            \
{                                                                                                 \
  VALUE sm_rhs;                                                                                   \
  VALUE sm_out;                                                                                   \
  TYPE##_t *self;                                                                                 \
  RHSTYPE##_t *rhs;                                                                               \
  rb_scan_args(argc, argv, "11", &sm_rhs, &sm_out);                                               \
  self = SM_UNWRAP(TYPE)(sm_self, NULL);                                                          \
  SM_RAISE_IF_NOT_TYPE(sm_rhs, RHSTYPE);                                                          \
  rhs = SM_UNWRAP(RHSTYPE)(sm_rhs, NULL);                                                         \
  if (argc == 2) {                                                                                \
    if (!RTEST(sm_out)) {                                                                         \
      goto SM_LABEL(skip_output);                                                                 \
    }{                                                                                            \
    SM_RAISE_IF_NOT_TYPE(sm_out, OTYPE);                                                          \
    OTYPE##_t *output = SM_UNWRAP(OTYPE)(sm_out, NULL);                                           \
    TYPE##_##FUNC (*self, *rhs, *output);                                                         \
  }} else if (argc == 1) {                                                                        \
SM_LABEL(skip_output): {                                                                          \
    OTYPE##_t output;                                                                             \
    TYPE##_##FUNC (*self, *rhs, output);                                                          \
    sm_out = SM_WRAP(OTYPE)(output, (SM_KLASS(OTYPE) == SM_KLASS(TYPE)                            \
          ? rb_obj_class(sm_self)                                                                 \
          : (SM_KLASS(OTYPE) == SM_KLASS(RHSTYPE)                                                 \
            ? rb_obj_class(sm_rhs)                                                                \
            : SM_KLASS(OTYPE))));                                                                 \
    rb_obj_call_init(sm_out, 0, 0);                                                               \
  }} else {                                                                                       \
    rb_raise(rb_eArgError, "Invalid number of arguments to " #FUNC);                              \
  }                                                                                               \
  return sm_out;                                                                                  \
}

/*
  Defines a unary op for the given type (defined as TYPE_FUNC(input, output)
  where input is self and output is either nil or an arbitrary value of type
  OTYPE to store the result in).

  By default, if no output object is provided, a new one is created and
  returned. If an output object is provided, it is returned.
*/
#define DEF_SM_UNARY_OP(FUNC, TYPE, OTYPE)                                                        \
static VALUE sm_##TYPE##_##FUNC (int argc, VALUE *argv, VALUE sm_self)                            \
{                                                                                                 \
  VALUE sm_out;                                                                                   \
  TYPE##_t *self;                                                                                 \
  rb_scan_args(argc, argv, "01", &sm_out);                                                        \
  self = SM_UNWRAP(TYPE)(sm_self, NULL);                                                          \
  if (argc == 1) {                                                                                \
    if (!RTEST(sm_out)) {                                                                         \
      goto SM_LABEL(skip_output);                                                                 \
    }{                                                                                            \
    SM_RAISE_IF_NOT_TYPE(sm_out, OTYPE);                                                          \
    OTYPE##_t *output = SM_UNWRAP(OTYPE)(sm_out, NULL);                                           \
    TYPE##_##FUNC (*self, *output);                                                               \
  }} else if (argc == 0) {                                                                        \
SM_LABEL(skip_output): {                                                                          \
    OTYPE##_t output;                                                                             \
    TYPE##_##FUNC (*self, output);                                                                \
    sm_out = SM_WRAP(OTYPE)(output, (SM_KLASS(OTYPE) == SM_KLASS(TYPE)                            \
          ? rb_obj_class(sm_self)                                                                 \
          : SM_KLASS(OTYPE)));                                                                    \
    rb_obj_call_init(sm_out, 0, 0);                                                               \
  }} else {                                                                                       \
    rb_raise(rb_eArgError, "Invalid number of arguments to " #FUNC);                              \
  }                                                                                               \
  return sm_out;                                                                                  \
}

/* Deref/fetch op for a given type. Does bounds-checking. */
#define DEF_SM_FETCH_OP(TYPE)                                                                     \
static VALUE sm_##TYPE##_fetch (VALUE sm_self, VALUE sm_index)                                    \
{                                                                                                 \
  static const int max_index = sizeof(TYPE##_t) / sizeof(s_float_t);                              \
  const TYPE##_t *self = SM_UNWRAP(TYPE)(sm_self, NULL);                                          \
  int index = NUM2INT(sm_index);                                                                  \
  if (index < 0 || index >= max_index) {                                                          \
    rb_raise(rb_eRangeError,                                                                      \
      "Index %d is out of bounds, must be from 0 through %d", index, max_index - 1);              \
  }                                                                                               \
  return rb_float_new(self[0][NUM2INT(sm_index)]);                                                \
}

/* Deref-assignment/store op for a given type. Does bounds-checking. */
#define DEF_SM_STORE_OP(TYPE)                                                                     \
static VALUE sm_##TYPE##_store (VALUE sm_self, VALUE sm_index, VALUE sm_value)                    \
{                                                                                                 \
  static const int max_index = sizeof(TYPE##_t) / sizeof(s_float_t);                              \
  TYPE##_t *self = SM_UNWRAP(TYPE)(sm_self, NULL);                                                \
  int index = NUM2INT(sm_index);                                                                  \
  if (index < 0 || index >= max_index) {                                                          \
    rb_raise(rb_eRangeError,                                                                      \
      "Index %d is out of bounds, must be from 0 through %d", index, max_index - 1);              \
  }                                                                                               \
  self[0][index] = (s_float_t)rb_num2dbl(sm_value);                                               \
  return sm_value;                                                                                \
}

/* Size op. Returns the size in bytes of a given type. */
#define DEF_SM_SIZE_OP(TYPE)                                                                      \
static VALUE sm_##TYPE##_size (VALUE self)                                                        \
{                                                                                                 \
  return SIZET2NUM(sizeof(TYPE##_t));                                                             \
}

/* Length op. Returns the size in s_float_t elements of the given type. */
#define DEF_SM_LENGTH_OP(TYPE)                                                                    \
static VALUE sm_##TYPE##_length (VALUE self)                                                      \
{                                                                                                 \
  return SIZET2NUM(sizeof(TYPE##_t) / sizeof(s_float_t));                                         \
}



/*
  Array types -- optional if BUILD_ARRAY_TYPE isn't defined.

  All array types are defined as something like this in Ruby:

  class TypeArray
    def fetch(index) -> Type
      Returns an  Object of Type that references array data (non-const)

    def store(index, value) -> value
      Copies value object of Type's data to the array's data. This is a nop if
      the value already references the array's data.
  end
*/
#define BUILD_ARRAY_TYPE
#ifdef BUILD_ARRAY_TYPE

static ID kRB_IVAR_MATHARRAY_LENGTH;
static ID kRB_IVAR_MATHARRAY_SOURCE;

static VALUE sm_mathtype_array_length(VALUE sm_self)
{
  return rb_ivar_get(sm_self, kRB_IVAR_MATHARRAY_LENGTH);
}

#define SM_ARR_KLASS(ELEM_TYPE) SM_KLASS(ELEM_TYPE##_array)

#define REG_SM_ARR_TYPE(ELEM_TYPE, NAME) do {                                                     \
    VALUE klass_ =                                                                                \
    SM_ARR_KLASS(ELEM_TYPE) = rb_define_class_under(s_sm_snowmath_mod, NAME, rb_cObject);         \
    rb_define_singleton_method(klass_, "new", sm_##ELEM_TYPE##_array_new, 1);                     \
    rb_define_method(klass_, "fetch", sm_##ELEM_TYPE##_array_fetch, 1);                           \
    rb_define_method(klass_, "store", sm_##ELEM_TYPE##_array_store, 2);                           \
    rb_define_method(klass_, "resize!", sm_##ELEM_TYPE##_array_resize, 1);                        \
    rb_define_method(klass_, "size", sm_##ELEM_TYPE##_array_size, 0);                             \
    rb_define_method(klass_, "length", sm_mathtype_array_length, 0);                              \
    rb_define_method(klass_, "address", sm_get_address, 0);                                       \
  } while (0)

#define DEF_SM_ARR_TYPE(ELEM_TYPE)                                                                \
static VALUE SM_ARR_KLASS(ELEM_TYPE) = Qnil;                                                      \
                                                                                                  \
static VALUE sm_##ELEM_TYPE##_array_new(VALUE sm_self, VALUE sm_length_or_copy)                   \
{                                                                                                 \
  size_t length = 0;                                                                              \
  ELEM_TYPE##_t *arr;                                                                             \
  VALUE sm_type_array;                                                                            \
  int copy_array = 0;                                                                             \
  if ((copy_array = SM_IS_A(sm_length_or_copy, ELEM_TYPE##_array))) {                             \
    length = NUM2SIZET(sm_mathtype_array_length(sm_length_or_copy));                              \
  } else {                                                                                        \
    length = NUM2SIZET(sm_length_or_copy);                                                        \
  }                                                                                               \
  if (length <= 0) {                                                                              \
    return Qnil;                                                                                  \
  }                                                                                               \
  arr = ALLOC_N(ELEM_TYPE##_t, length);                                                           \
  if (copy_array) {                                                                               \
    const ELEM_TYPE##_t *source;                                                                  \
    Data_Get_Struct(sm_length_or_copy, ELEM_TYPE##_t, source);                                    \
    MEMCPY(arr, source, ELEM_TYPE##_t, length);                                                   \
    sm_length_or_copy = sm_mathtype_array_length(sm_length_or_copy);                              \
  }                                                                                               \
  sm_type_array = Data_Wrap_Struct(sm_self, 0, free, arr);                                        \
  rb_ivar_set(sm_type_array, kRB_IVAR_MATHARRAY_LENGTH, sm_length_or_copy);                       \
  rb_obj_call_init(sm_type_array, 0, 0);                                                          \
  return sm_type_array;                                                                           \
}                                                                                                 \
                                                                                                  \
static VALUE sm_##ELEM_TYPE##_array_resize(VALUE sm_self, VALUE sm_new_length)                    \
{                                                                                                 \
  size_t new_length;                                                                              \
  new_length = NUM2SIZET(sm_new_length);                                                          \
  REALLOC_N(RDATA(sm_self)->data, ELEM_TYPE##_t, new_length);                                     \
  rb_ivar_set(sm_self, kRB_IVAR_MATHARRAY_LENGTH, sm_new_length);                                 \
  return sm_self;                                                                                 \
}                                                                                                 \
                                                                                                  \
static VALUE sm_##ELEM_TYPE##_array_fetch(VALUE sm_self, VALUE sm_index)                          \
{                                                                                                 \
  ELEM_TYPE##_t *arr;                                                                             \
  size_t length = NUM2SIZET(sm_mathtype_array_length(sm_self));                                   \
  size_t index = NUM2SIZET(sm_index);                                                             \
  VALUE sm_inner;                                                                                 \
  if (index < 0 || index >= length) {                                                             \
    rb_raise(rb_eRangeError,                                                                      \
      "Index %zu out of bounds for array with length %zu",                                        \
      index, length);                                                                             \
  }                                                                                               \
  Data_Get_Struct(sm_self, ELEM_TYPE##_t, arr);                                                   \
  sm_inner = Data_Wrap_Struct(SM_KLASS(ELEM_TYPE), 0, 0, arr[index]);                             \
  rb_ivar_set(sm_inner, kRB_IVAR_MATHARRAY_SOURCE, sm_self);                                      \
  return sm_inner;                                                                                \
}                                                                                                 \
                                                                                                  \
static VALUE sm_##ELEM_TYPE##_array_store(VALUE sm_self, VALUE sm_index, VALUE sm_value)          \
{                                                                                                 \
  ELEM_TYPE##_t *arr;                                                                             \
  ELEM_TYPE##_t *value;                                                                           \
  size_t length = NUM2SIZET(sm_mathtype_array_length(sm_self));                                   \
  size_t index = NUM2SIZET(sm_index);                                                             \
  if (index < 0 || index >= length) {                                                             \
    rb_raise(rb_eRangeError,                                                                      \
      "Index %zu out of bounds for array with length %zu",                                        \
      index, length);                                                                             \
  } else if (!SM_IS_A(sm_value, ELEM_TYPE)) {                                                     \
    rb_raise(rb_eTypeError,                                                                       \
      "Invalid value to store: expected %s, got %s",                                              \
      rb_class2name(SM_KLASS(ELEM_TYPE)),                                                         \
      rb_obj_classname(sm_value));                                                                \
  }                                                                                               \
  Data_Get_Struct(sm_self, ELEM_TYPE##_t, arr);                                                   \
  value = SM_UNWRAP(ELEM_TYPE)(sm_value, NULL);                                                   \
  if ((void *)value >= (void *)arr && (void *)value < (void *)(&arr[length])) {                   \
    return sm_value;                                                                              \
  }                                                                                               \
  ELEM_TYPE##_copy(*value, arr[index]);                                                           \
  return sm_value;                                                                                \
}                                                                                                 \
                                                                                                  \
static VALUE sm_##ELEM_TYPE##_array_size(VALUE sm_self)                                           \
{                                                                                                 \
  size_t length = NUM2SIZET(sm_mathtype_array_length(sm_self));                                   \
  return SIZET2NUM(length * sizeof(ELEM_TYPE##_t));                                               \
}

#endif


/*==============================================================================

  Static Ruby class / module values

==============================================================================*/

static VALUE s_sm_snowmath_mod = Qnil;
DEF_SM_TYPE_KLASS(vec3);
DEF_SM_TYPE_KLASS(vec4);
DEF_SM_TYPE_KLASS(quat);
DEF_SM_TYPE_KLASS(mat3);
DEF_SM_TYPE_KLASS(mat4);

// Declare wrapping operations
DECL_SM_UNWRAP_OP(vec3);
DECL_SM_UNWRAP_OP(vec4);
DECL_SM_UNWRAP_OP(quat);
DECL_SM_UNWRAP_OP(mat3);
DECL_SM_UNWRAP_OP(mat4);

// Declare unwrapping operations
DECL_SM_WRAP_OP(vec3);
DECL_SM_WRAP_OP(vec4);
DECL_SM_WRAP_OP(quat);
DECL_SM_WRAP_OP(mat3);
DECL_SM_WRAP_OP(mat4);



/*==============================================================================

  Array types

==============================================================================*/

#ifdef BUILD_ARRAY_TYPE
DEF_SM_ARR_TYPE(vec3);
DEF_SM_ARR_TYPE(vec4);
DEF_SM_ARR_TYPE(quat);
DEF_SM_ARR_TYPE(mat3);
DEF_SM_ARR_TYPE(mat4);
#endif



/*==============================================================================

  vec3_t functions

==============================================================================*/

DEF_SM_WRAP_OP(vec3);
DEF_SM_UNWRAP_OP(vec3);
DEF_SM_SIZE_OP(vec3);
DEF_SM_LENGTH_OP(vec3);
DEF_SM_FETCH_OP(vec3);
DEF_SM_STORE_OP(vec3);
DEF_SM_UNARY_OP(copy, vec3, vec3);
DEF_SM_UNARY_OP(normalize, vec3, vec3);
DEF_SM_UNARY_OP(inverse, vec3, vec3);
DEF_SM_UNARY_OP(negate, vec3, vec3);
DEF_SM_BINARY_OP(project, vec3, vec3, vec3);
DEF_SM_BINARY_OP(reflect, vec3, vec3, vec3);
DEF_SM_BINARY_OP(cross_product, vec3, vec3, vec3);
DEF_SM_BINARY_OP(multiply, vec3, vec3, vec3);
DEF_SM_BINARY_OP(add, vec3, vec3, vec3);
DEF_SM_BINARY_OP(subtract, vec3, vec3, vec3);

static VALUE sm_vec3_dot_product(VALUE sm_self, VALUE sm_other)
{
  if (!SM_IS_A(sm_other, vec3) &&
      !SM_IS_A(sm_other, vec4) &&
      !SM_IS_A(sm_other, quat)) {
    rb_raise(rb_eArgError,
      "Expected a Quat, Vec3, or Vec4, got %s",
      rb_obj_classname(sm_other));
    return Qnil;
  }
  return rb_float_new(
    vec3_dot_product(
      *sm_unwrap_vec3(sm_self, NULL),
      *sm_unwrap_vec3(sm_other, NULL)));
}



static VALUE sm_vec3_new(int argc, VALUE *argv, VALUE self)
{
  VALUE sm_vec = sm_wrap_vec3(g_vec3_zero, self);
  rb_obj_call_init(sm_vec, argc, argv);
  return sm_vec;
}



static VALUE sm_vec3_init(int argc, VALUE *argv, VALUE sm_self)
{
  vec3_t *self = sm_unwrap_vec3(sm_self, NULL);
  size_t arr_index = 0;

  switch(argc) {

  // Default value
  case 0: { break; }

  // Copy or by-array
  case 1: {
    if (SM_IS_A(argv[0], vec3) ||
        SM_IS_A(argv[0], vec4) ||
        SM_IS_A(argv[0], quat)) {
      sm_unwrap_vec3(argv[0], *self);
      break;
    }

    // Optional offset into array provided
    if (0) {
      case 2:
      arr_index = NUM2SIZET(argv[1]);
    }

    // Array of values
    if (SM_RB_IS_A(argv[0], rb_cArray)) {
      VALUE arrdata = argv[0];
      const size_t arr_end = arr_index + 3;
      s_float_t *vec_elem = *self;
      for (; arr_index < arr_end; ++arr_index, ++vec_elem) {
        *vec_elem = (s_float_t)rb_num2dbl(rb_ary_entry(arrdata, (long)arr_index));
      }
      break;
    }

    rb_raise(rb_eArgError, "Expected either an array of Numerics or a Vec3");
    break;
  }

  // X, Y, Z
  case 3: {
    self[0][0] = (s_float_t)rb_num2dbl(argv[0]);
    self[0][1] = (s_float_t)rb_num2dbl(argv[1]);
    self[0][2] = (s_float_t)rb_num2dbl(argv[2]);
    break;
  }

  default: {
    rb_raise(rb_eArgError, "Invalid arguments to Vec3.initialize");
    break;
  }
  } // switch (argc)

  return sm_self;
}



static VALUE sm_vec3_to_s(VALUE self)
{
  const s_float_t *v;
  v = (const s_float_t *)*sm_unwrap_vec3(self, NULL);
  return rb_sprintf(
    "{ "
    "%f, %f, %f"
    " }",
    v[0], v[1], v[2]);
}



static VALUE sm_vec3_magnitude_squared(VALUE sm_self)
{
  return rb_float_new(vec3_length_squared(*sm_unwrap_vec3(sm_self, NULL)));
}



static VALUE sm_vec3_magnitude(VALUE sm_self)
{
  return rb_float_new(vec3_length(*sm_unwrap_vec3(sm_self, NULL)));
}



static VALUE sm_vec3_scale(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out;
  VALUE sm_scalar;
  s_float_t scalar;
  vec3_t *self = sm_unwrap_vec3(sm_self, NULL);

  rb_scan_args(argc, argv, "11", &sm_scalar, &sm_out);
  scalar = rb_num2dbl(sm_scalar);

  if (SM_IS_A(sm_out, vec3)) {
    vec3_scale(*self, scalar, *sm_unwrap_vec3(sm_out, NULL));
  } else {
    vec3_t out;
    vec3_scale(*self, scalar, out);
    sm_out = sm_wrap_vec3(out, rb_obj_class(sm_self));
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_vec3_divide(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out;
  VALUE sm_scalar;
  s_float_t scalar;
  vec3_t *self = sm_unwrap_vec3(sm_self, NULL);

  rb_scan_args(argc, argv, "11", &sm_scalar, &sm_out);
  scalar = rb_num2dbl(sm_scalar);

  if (SM_IS_A(sm_out, vec3)) {
    vec3_divide(*self, scalar, *sm_unwrap_vec3(sm_out, NULL));
  } else {
    vec3_t out;
    vec3_divide(*self, scalar, out);
    sm_out = sm_wrap_vec3(out, rb_obj_class(sm_self));
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_vec3_equals(VALUE sm_self, VALUE sm_other)
{
  if (!RTEST(sm_other)) {
    return Qfalse;
  } else if (!SM_IS_A(sm_other, vec3) && !SM_IS_A(sm_other, vec4) && !SM_IS_A(sm_other, quat)) {
    rb_raise(rb_eTypeError,
      "Expected Vec3, Vec4, or Quat, got %s",
      rb_obj_classname(sm_other));
  }

  return vec3_equals(*sm_unwrap_vec3(sm_self, NULL), *sm_unwrap_vec3(sm_other, NULL)) ? Qtrue : Qfalse;
}



/*==============================================================================

  vec4_t functions

==============================================================================*/

DEF_SM_WRAP_OP(vec4);
DEF_SM_UNWRAP_OP(vec4);
DEF_SM_SIZE_OP(vec4);
DEF_SM_LENGTH_OP(vec4);
DEF_SM_FETCH_OP(vec4);
DEF_SM_STORE_OP(vec4);
DEF_SM_UNARY_OP(copy, vec4, vec4);
DEF_SM_UNARY_OP(normalize, vec4, vec4);
DEF_SM_UNARY_OP(inverse, vec4, vec4);
DEF_SM_UNARY_OP(negate, vec4, vec4);
DEF_SM_BINARY_OP(project, vec4, vec4, vec4);
DEF_SM_BINARY_OP(reflect, vec4, vec4, vec4);
DEF_SM_BINARY_OP(multiply, vec4, vec4, vec4);
DEF_SM_BINARY_OP(add, vec4, vec4, vec4);
DEF_SM_BINARY_OP(subtract, vec4, vec4, vec4);

static VALUE sm_vec4_dot_product(VALUE sm_self, VALUE sm_other)
{
  if (!SM_IS_A(sm_other, vec4) &&
      !SM_IS_A(sm_other, quat)) {
    rb_raise(rb_eArgError,
      "Expected a Quat or Vec4, got %s",
      rb_obj_classname(sm_other));
    return Qnil;
  }
  return rb_float_new(
    vec4_dot_product(
      *sm_unwrap_vec4(sm_self, NULL),
      *sm_unwrap_vec4(sm_other, NULL)));
}



static VALUE sm_vec4_new(int argc, VALUE *argv, VALUE self)
{
  VALUE sm_vec = sm_wrap_vec4(g_vec4_identity, self);
  rb_obj_call_init(sm_vec, argc, argv);
  return sm_vec;
}



static VALUE sm_vec4_init(int argc, VALUE *argv, VALUE sm_self)
{
  vec4_t *self = sm_unwrap_vec4(sm_self, NULL);
  size_t arr_index = 0;

  switch(argc) {

  // Default value
  case 0: { break; }

  // Copy or by-array
  case 1: {
    if (SM_IS_A(argv[0], quat) ||
        SM_IS_A(argv[0], vec4)) {
      sm_unwrap_quat(argv[0], *self);
      break;
    }

    if (SM_IS_A(argv[0], vec3)) {
      sm_unwrap_vec3(argv[0], *self);
      break;
    }

    // Optional offset into array provided
    if (0) {
      case 2:
      arr_index = NUM2SIZET(argv[1]);
    }

    // Array of values
    if (SM_RB_IS_A(argv[0], rb_cArray)) {
      VALUE arrdata = argv[0];
      const size_t arr_end = arr_index + 4;
      s_float_t *vec_elem = *self;
      for (; arr_index < arr_end; ++arr_index, ++vec_elem) {
        *vec_elem = (s_float_t)rb_num2dbl(rb_ary_entry(arrdata, (long)arr_index));
      }
      break;
    }

    rb_raise(rb_eArgError, "Expected either an array of Numerics or a Vec4");
    break;
  }

  // W
  case 4: {
    self[0][3] = (s_float_t)rb_num2dbl(argv[3]);
    case 3: // X, Y, Z
    self[0][0] = (s_float_t)rb_num2dbl(argv[0]);
    self[0][1] = (s_float_t)rb_num2dbl(argv[1]);
    self[0][2] = (s_float_t)rb_num2dbl(argv[2]);
    break;
  }

  default: {
    rb_raise(rb_eArgError, "Invalid arguments to Vec4.initialize");
    break;
  }
  } // switch (argc)

  return sm_self;
}



static VALUE sm_vec4_to_s(VALUE self)
{
  const s_float_t *v;
  v = (const s_float_t *)*sm_unwrap_vec4(self, NULL);
  return rb_sprintf(
    "{ "
    "%f, %f, %f, %f"
    " }",
    v[0], v[1], v[2], v[3]);
}



static VALUE sm_vec4_magnitude_squared(VALUE sm_self)
{
  return rb_float_new(vec4_length_squared(*sm_unwrap_vec4(sm_self, NULL)));
}



static VALUE sm_vec4_magnitude(VALUE sm_self)
{
  return rb_float_new(vec4_length(*sm_unwrap_vec4(sm_self, NULL)));
}



static VALUE sm_vec4_scale(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out;
  VALUE sm_scalar;
  s_float_t scalar;
  vec4_t *self = sm_unwrap_vec4(sm_self, NULL);

  rb_scan_args(argc, argv, "11", &sm_scalar, &sm_out);
  scalar = rb_num2dbl(sm_scalar);

  if ((SM_IS_A(sm_out, vec4) || SM_IS_A(sm_out, quat))) {
    vec4_scale(*self, scalar, *sm_unwrap_vec4(sm_out, NULL));
  } else {
    vec4_t out;
    vec4_scale(*self, scalar, out);
    sm_out = sm_wrap_vec4(out, rb_obj_class(sm_self));
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_vec4_divide(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out;
  VALUE sm_scalar;
  s_float_t scalar;
  vec4_t *self = sm_unwrap_vec4(sm_self, NULL);

  rb_scan_args(argc, argv, "11", &sm_scalar, &sm_out);
  scalar = rb_num2dbl(sm_scalar);

  if ((SM_IS_A(sm_out, vec4) || SM_IS_A(sm_out, quat))) {
    vec4_divide(*self, scalar, *sm_unwrap_vec4(sm_out, NULL));
  } else {
    vec4_t out;
    vec4_divide(*self, scalar, out);
    sm_out = sm_wrap_vec4(out, rb_obj_class(sm_self));
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_vec4_equals(VALUE sm_self, VALUE sm_other)
{
  if (!RTEST(sm_other)) {
    return Qfalse;
  } else if (!SM_IS_A(sm_other, vec4) && !SM_IS_A(sm_other, quat)) {
    rb_raise(rb_eTypeError,
      "Expected Vec4 or Quat, got %s",
      rb_obj_classname(sm_other));
  }

  return vec4_equals(*sm_unwrap_vec4(sm_self, NULL), *sm_unwrap_vec4(sm_other, NULL)) ? Qtrue : Qfalse;
}



/*==============================================================================

  quat_t functions

==============================================================================*/

DEF_SM_WRAP_OP(quat);
DEF_SM_UNWRAP_OP(quat);
DEF_SM_SIZE_OP(quat);
DEF_SM_LENGTH_OP(quat);
DEF_SM_FETCH_OP(quat);
DEF_SM_STORE_OP(quat);
DEF_SM_UNARY_OP(copy, quat, quat);
DEF_SM_UNARY_OP(inverse, quat, quat);
DEF_SM_UNARY_OP(negate, quat, quat);
DEF_SM_BINARY_OP(multiply, quat, quat, quat);
DEF_SM_BINARY_OP(multiply_vec3, quat, vec3, vec3);

static VALUE sm_quat_new(int argc, VALUE *argv, VALUE self)
{
  VALUE sm_quat = sm_wrap_quat(g_quat_identity, self);
  rb_obj_call_init(sm_quat, argc, argv);
  return sm_quat;
}



static VALUE sm_quat_init(int argc, VALUE *argv, VALUE sm_self)
{
  quat_t *self = sm_unwrap_quat(sm_self, NULL);
  size_t arr_index = 0;

  switch(argc) {

  // Default value
  case 0: { break; }

  // Copy or by-array
  case 1: {
    if (SM_IS_A(argv[0], vec3)) {
      sm_unwrap_vec3(argv[0], *self);
      break;
    }

    if (SM_IS_A(argv[0], quat) ||
        SM_IS_A(argv[0], vec4)) {
      sm_unwrap_quat(argv[0], *self);
      break;
    }

    if (SM_IS_A(argv[0], mat4)) {
      const mat4_t *mat = sm_unwrap_mat4(argv[0], NULL);
      quat_from_mat4(*mat, *self);
      break;
    }

    if (SM_IS_A(argv[0], mat3)) {
      const mat3_t *mat = sm_unwrap_mat3(argv[0], NULL);
      quat_from_mat3(*mat, *self);
      break;
    }

    // Optional offset into array provided
    if (0) {
      case 2:
      arr_index = NUM2SIZET(argv[1]);
    }

    // Array of values
    if (SM_RB_IS_A(argv[0], rb_cArray)) {
      VALUE arrdata = argv[0];
      const size_t arr_end = arr_index + 3;
      s_float_t *vec_elem = *self;
      for (; arr_index < arr_end; ++arr_index, ++vec_elem) {
        *vec_elem = (s_float_t)rb_num2dbl(rb_ary_entry(arrdata, (long)arr_index));
      }
      break;
    }

    rb_raise(rb_eArgError, "Expected either an array of Numerics or a Quat");
    break;
  }

  // W
  case 4: {
    self[0][3] = (s_float_t)rb_num2dbl(argv[3]);
    case 3: // X, Y, Z
    self[0][0] = (s_float_t)rb_num2dbl(argv[0]);
    self[0][1] = (s_float_t)rb_num2dbl(argv[1]);
    self[0][2] = (s_float_t)rb_num2dbl(argv[2]);
    break;
  }

  default: {
    rb_raise(rb_eArgError, "Invalid arguments to Quat.initialize");
    break;
  }
  } // switch (argc)

  return sm_self;
}



static VALUE sm_quat_to_s(VALUE self)
{
  const s_float_t *v;
  v = (const s_float_t *)*sm_unwrap_quat(self, NULL);
  return rb_sprintf(
    "{ "
    "%f, %f, %f, %f"
    " }",
    v[0], v[1], v[2], v[3]);
}



static VALUE sm_quat_angle_axis(int argc, VALUE *argv, VALUE self)
{
  VALUE sm_angle;
  VALUE sm_axis;
  VALUE sm_out;
  s_float_t angle;
  const vec3_t *axis;

  rb_scan_args(argc, argv, "21", &sm_angle, &sm_axis, &sm_out);
  SM_RAISE_IF_NOT_TYPE(sm_axis, vec3);

  angle = (s_float_t)rb_num2dbl(sm_angle);
  axis = sm_unwrap_vec3(sm_axis, NULL);

  if (SM_IS_A(sm_out, quat) || SM_IS_A(sm_out, vec4)) {
    quat_t *out = sm_unwrap_quat(sm_out, NULL);
    quat_from_angle_axis(angle, (*axis)[0], (*axis)[1], (*axis)[2], *out);
  } else {
    quat_t out;
    quat_from_angle_axis(angle, (*axis)[0], (*axis)[1], (*axis)[2], out);
    sm_out = sm_wrap_quat(out, self);
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_quat_identity(VALUE sm_self)
{
  quat_t *self = sm_unwrap_quat(sm_self, NULL);
  quat_identity(*self);
  return sm_self;
}



static VALUE sm_quat_scale(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out;
  VALUE sm_scalar;
  s_float_t scalar;
  vec4_t *self = sm_unwrap_vec4(sm_self, NULL);

  rb_scan_args(argc, argv, "11", &sm_scalar, &sm_out);
  scalar = rb_num2dbl(sm_scalar);

  if ((SM_IS_A(sm_out, vec4) || SM_IS_A(sm_out, quat))) {
    vec4_scale(*self, scalar, *sm_unwrap_vec4(sm_out, NULL));
  } else {
    vec4_t out;
    vec4_scale(*self, scalar, out);
    sm_out = sm_wrap_quat(out, rb_obj_class(sm_self));
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_quat_divide(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out;
  VALUE sm_scalar;
  s_float_t scalar;
  vec4_t *self = sm_unwrap_vec4(sm_self, NULL);

  rb_scan_args(argc, argv, "11", &sm_scalar, &sm_out);
  scalar = rb_num2dbl(sm_scalar);

  if ((SM_IS_A(sm_out, vec4) || SM_IS_A(sm_out, quat))) {
    vec4_divide(*self, scalar, *sm_unwrap_vec4(sm_out, NULL));
  } else {
    vec4_t out;
    vec4_divide(*self, scalar, out);
    sm_out = sm_wrap_quat(out, rb_obj_class(sm_self));
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_quat_slerp(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out;
  VALUE sm_destination;
  VALUE sm_alpha;
  quat_t *destination;
  quat_t *self = sm_unwrap_vec4(sm_self, NULL);
  s_float_t alpha;

  rb_scan_args(argc, argv, "21", &sm_destination, &sm_alpha, &sm_out);
  alpha = rb_num2dbl(sm_alpha);

  if (!SM_IS_A(sm_destination, vec4) && !SM_IS_A(sm_destination, quat)) {
    rb_raise(rb_eTypeError,
      "Expected either Vec4 or Quat, got %s",
      rb_obj_classname(sm_destination));
    return Qnil;
  }

  destination = sm_unwrap_quat(sm_destination, NULL);

  if ((SM_IS_A(sm_out, vec4) || SM_IS_A(sm_out, quat))) {
    quat_slerp(*self, *destination, alpha, *sm_unwrap_quat(sm_out, NULL));
  } else {
    quat_t out;
    quat_slerp(*self, *destination, alpha, out);
    sm_out = sm_wrap_quat(out, rb_obj_class(sm_self));
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_quat_normalize(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out;
  VALUE sm_scalar;
  s_float_t scalar;
  vec4_t *self = sm_unwrap_vec4(sm_self, NULL);

  rb_scan_args(argc, argv, "01", &sm_scalar, &sm_out);
  scalar = rb_num2dbl(sm_scalar);

  if ((SM_IS_A(sm_out, vec4) || SM_IS_A(sm_out, quat))) {
    vec4_normalize(*self, *sm_unwrap_vec4(sm_out, NULL));
  } else {
    vec4_t out;
    vec4_normalize(*self, out);
    sm_out = sm_wrap_quat(out, rb_obj_class(sm_self));
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_quat_add(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out;
  VALUE sm_left;
  vec4_t *self = sm_unwrap_vec4(sm_self, NULL);

  rb_scan_args(argc, argv, "11", &sm_left, &sm_out);

  if (!SM_IS_A(sm_left, vec4) && !SM_IS_A(sm_left, quat)) {
    rb_raise(rb_eTypeError,
      "Expected either Vec4 or Quat, got %s",
      rb_obj_classname(sm_left));
    return Qnil;
  }

  if ((SM_IS_A(sm_out, vec4) || SM_IS_A(sm_out, quat))) {
    vec4_add(*self, *sm_unwrap_vec4(sm_left, NULL), *sm_unwrap_vec4(sm_out, NULL));
  } else {
    vec4_t out;
    vec4_add(*self, *sm_unwrap_vec4(sm_left, NULL), out);
    sm_out = sm_wrap_quat(out, rb_obj_class(sm_self));
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_quat_subtract(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out;
  VALUE sm_left;
  vec4_t *self = sm_unwrap_vec4(sm_self, NULL);

  rb_scan_args(argc, argv, "11", &sm_left, &sm_out);

  if (!SM_IS_A(sm_left, vec4) && !SM_IS_A(sm_left, quat)) {
    rb_raise(rb_eTypeError,
      "Expected either Vec4 or Quat, got %s",
      rb_obj_classname(sm_left));
    return Qnil;
  }

  if ((SM_IS_A(sm_out, vec4) || SM_IS_A(sm_out, quat))) {
    vec4_subtract(*self, *sm_unwrap_vec4(sm_left, NULL), *sm_unwrap_vec4(sm_out, NULL));
  } else {
    vec4_t out;
    vec4_subtract(*self, *sm_unwrap_vec4(sm_left, NULL), out);
    sm_out = sm_wrap_quat(out, rb_obj_class(sm_self));
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



/*==============================================================================

  mat4_t functions

==============================================================================*/

DEF_SM_WRAP_OP(mat4);
DEF_SM_UNWRAP_OP(mat4);
DEF_SM_SIZE_OP(mat4);
DEF_SM_LENGTH_OP(mat4);
DEF_SM_FETCH_OP(mat4);
DEF_SM_STORE_OP(mat4);
DEF_SM_UNARY_OP(copy, mat4, mat4);
DEF_SM_UNARY_OP(to_mat3, mat4, mat3);
DEF_SM_UNARY_OP(transpose, mat4, mat4);
DEF_SM_UNARY_OP(inverse_orthogonal, mat4, mat4);
DEF_SM_UNARY_OP(adjoint, mat4, mat4);
DEF_SM_BINARY_OP(multiply, mat4, mat4, mat4);
DEF_SM_BINARY_OP(multiply_vec4, mat4, vec4, vec4);
DEF_SM_BINARY_OP(transform_vec3, mat4, vec3, vec3);
DEF_SM_BINARY_OP(rotate_vec3, mat4, vec3, vec3);
DEF_SM_BINARY_OP(inv_rotate_vec3, mat4, vec3, vec3);

static VALUE sm_mat4_inverse_affine(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out = Qnil;
  mat4_t *self;

  rb_scan_args(argc, argv, "01", &sm_out);
  self = sm_unwrap_mat4(sm_self, NULL);

  if (argc == 1) {
    mat4_t *output;

    if (!RTEST(sm_out)) {
      goto SM_LABEL(output_lbl);
    }

    if (!SM_IS_A(sm_out, mat4)) {
      rb_raise(rb_eTypeError,
        "Invalid argument to output of inverse_affine: expected %s, got %s",
        rb_class2name(SM_KLASS(mat4)),
        rb_obj_classname(sm_out));
      return Qnil;
    }

    output = sm_unwrap_mat4(sm_out, NULL);
    if (!mat4_inverse_affine(*self, *output)) {
      return Qnil;
    }

  } else if (argc == 0) {
    SM_LABEL(output_lbl): {
      mat4_t output;
      if (!mat4_inverse_affine(*self, output)) {
        return Qnil;
      }

      sm_out = sm_wrap_mat4(output, rb_obj_class(sm_self));
      rb_obj_call_init(sm_out, 0, 0);
    }
  } else {
    rb_raise(rb_eArgError, "Invalid number of arguments to inverse_affine");
  }

  return sm_out;
}



static VALUE sm_mat4_inverse_general(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out = Qnil;
  mat4_t *self;

  rb_scan_args(argc, argv, "01", &sm_out);
  self = sm_unwrap_mat4(sm_self, NULL);

  if (argc == 1) {
    mat4_t *output;

    if (!RTEST(sm_out)) {
      goto SM_LABEL(skip_output);
    }

    if (!SM_IS_A(sm_out, mat4)) {
      rb_raise(rb_eTypeError,
        "Invalid argument to output of inverse_general: expected %s, got %s",
        rb_class2name(SM_KLASS(mat4)),
        rb_obj_classname(sm_out));
      return Qnil;
    }

    output = sm_unwrap_mat4(sm_out, NULL);
    if (!mat4_inverse_general(*self, *output)) {
      return Qnil;
    }

  } else if (argc == 0) {
    SM_LABEL(skip_output): {
      mat4_t output;
      if (!mat4_inverse_general(*self, output)) {
        return Qnil;
      }

      sm_out = sm_wrap_mat4(output, rb_obj_class(sm_self));
      rb_obj_call_init(sm_out, 0, 0);
    }
  } else {
    rb_raise(rb_eArgError, "Invalid number of arguments to inverse_general");
  }

  return sm_out;
}



static VALUE sm_mat4_determinant(VALUE sm_self)
{
  return mat4_determinant(*sm_unwrap_mat4(sm_self, NULL));
}



static VALUE sm_mat4_translate(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out = Qnil;
  mat4_t *self = sm_unwrap_mat4(sm_self, NULL);
  vec3_t xyz;

  SM_LABEL(argc_reconfig):
  switch (argc) {
  case 2: case 4: {
    sm_out = argv[--argc];
    if (RTEST(sm_out)) {
      SM_RAISE_IF_NOT_TYPE(sm_out, mat4);
    }
    goto SM_LABEL(argc_reconfig);
  }

  case 1: {
    sm_unwrap_vec3(argv[0], xyz);
    goto SM_LABEL(get_output);
  }

  case 3: {
    xyz[0] = rb_num2dbl(argv[0]);
    xyz[1] = rb_num2dbl(argv[1]);
    xyz[2] = rb_num2dbl(argv[2]);

    SM_LABEL(get_output):
    if (RTEST(sm_out)) {
      mat4_t *out = sm_unwrap_mat4(sm_out, NULL);
      mat4_translate(xyz[0], xyz[1], xyz[2], *self, *out);
    } else {
      mat4_t out;
      mat4_translate(xyz[0], xyz[1], xyz[2], *self, out);
      sm_out = sm_wrap_mat4(out, rb_obj_class(sm_self));
      rb_obj_call_init(sm_out, 0, 0);
    }
  }
  }

  return sm_out;
}



static VALUE sm_mat4_translation(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out = Qnil;
  vec3_t xyz;

  SM_LABEL(argc_reconfig):
  switch (argc) {
  case 2: case 4: {
    sm_out = argv[--argc];
    if (RTEST(sm_out)) {
      SM_RAISE_IF_NOT_TYPE(sm_out, mat4);
    }
    goto SM_LABEL(argc_reconfig);
  }

  case 1: {
    sm_unwrap_vec3(argv[0], xyz);
    goto SM_LABEL(get_output);
  }

  case 3: {
    xyz[0] = rb_num2dbl(argv[0]);
    xyz[1] = rb_num2dbl(argv[1]);
    xyz[2] = rb_num2dbl(argv[2]);

    SM_LABEL(get_output):
    if (RTEST(sm_out)) {
      mat4_t *out = sm_unwrap_mat4(sm_out, NULL);
      mat4_translation(xyz[0], xyz[1], xyz[2], *out);
    } else {
      mat4_t out;
      mat4_translation(xyz[0], xyz[1], xyz[2], out);
      sm_out = sm_wrap_mat4(out, sm_self);
      rb_obj_call_init(sm_out, 0, 0);
    }
  }
  }

  return sm_out;
}



static VALUE sm_mat4_new(int argc, VALUE *argv, VALUE self)
{
  VALUE sm_mat = sm_wrap_mat4(g_mat4_identity, self);
  rb_obj_call_init(sm_mat, argc, argv);
  return sm_mat;
}



static VALUE sm_mat4_init(int argc, VALUE *argv, VALUE sm_self)
{
  mat4_t *self = sm_unwrap_mat4(sm_self, NULL);
  size_t arr_index = 0;

  switch (argc) {

  case 0: {
    // Identity (handled in _new)
    break;
  }

  // Copy Mat4 or provided [Numeric..]
  case 1: {
    // Copy Mat4
    if (SM_IS_A(argv[0], mat4)) {
      sm_unwrap_mat4(argv[0], *self);
      break;
    }

    // Copy Mat3
    if (SM_IS_A(argv[0], mat3)) {
      mat3_to_mat4(*sm_unwrap_mat4(argv[0], NULL), *self);
      break;
    }

    // Build from Quaternion
    if (SM_IS_A(argv[0], quat)) {
      mat4_from_quat(*sm_unwrap_quat(argv[0], NULL), *self);
      break;
    }

    // Optional offset into array provided
    if (0) {
      case 2:
      arr_index = NUM2SIZET(argv[1]);
    }

    // Array of values
    if (SM_RB_IS_A(argv[0], rb_cArray)) {
      VALUE arrdata = argv[0];
      const size_t arr_end = arr_index + 16;
      s_float_t *mat_elem = *self;
      for (; arr_index < arr_end; ++arr_index, ++mat_elem) {
        *mat_elem = rb_num2dbl(rb_ary_entry(arrdata, (long)arr_index));
      }
      break;
    }

    rb_raise(rb_eArgError, "Expected either an array of Numerics or a Mat4");
    break;
  }

  // Mat4(Vec4, Vec4, Vec4, Vec4)
  case 4: {
    size_t arg_index;
    s_float_t *mat_elem = *self;
    for (arg_index = 0; arg_index < 4; ++arg_index, mat_elem += 4) {
      if (!SM_IS_A(argv[arg_index], vec4) && !SM_IS_A(argv[arg_index], quat)) {
        rb_raise(
          rb_eArgError,
          "Argument %d must be a Vec4 or Quat when supplying four arguments to Mat4.initialize",
          (int)(arg_index + 1));
      }

      sm_unwrap_vec4(argv[arg_index], mat_elem);
    }
    break;
  }

  // Mat4(Numeric m00 .. m16)
  case 16: {
    s_float_t *mat_elem = *self;
    VALUE *argv_p = argv;
    for (; argc; --argc, ++argv_p, ++mat_elem) {
      *mat_elem = (s_float_t)rb_num2dbl(*argv_p);
    }
    break;
  }

  default: {
    rb_raise(rb_eArgError, "Invalid arguments to Mat4.initialize");
    break;
  }
  } // swtich (argc)

  return sm_self;
}



static VALUE sm_mat4_to_s(VALUE self)
{
  const s_float_t *v;
  v = (const s_float_t *)*sm_unwrap_mat4(self, NULL);
  return rb_sprintf(
    "{ "
    "%f, %f, %f, %f" ",\n  "
    "%f, %f, %f, %f" ",\n  "
    "%f, %f, %f, %f" ",\n  "
    "%f, %f, %f, %f"
    " }",
    v[0], v[1], v[2], v[3],
    v[4], v[5], v[6], v[7],
    v[8], v[9], v[10], v[11],
    v[12], v[13], v[14], v[15]);
}



static VALUE sm_mat4_angle_axis(int argc, VALUE *argv, VALUE self)
{
  VALUE sm_angle;
  VALUE sm_axis;
  VALUE sm_out;
  s_float_t angle;
  const vec3_t *axis;

  rb_scan_args(argc, argv, "21", &sm_angle, &sm_axis, &sm_out);
  SM_RAISE_IF_NOT_TYPE(sm_axis, vec3);

  angle = (s_float_t)rb_num2dbl(sm_angle);
  axis = sm_unwrap_vec3(sm_axis, NULL);

  if (SM_IS_A(sm_out, mat4)) {
    mat4_t *out = sm_unwrap_mat4(sm_out, NULL);
    mat4_rotation(angle, (*axis)[0], (*axis)[1], (*axis)[2], *out);
  } else {
    mat4_t out;
    mat4_rotation(angle, (*axis)[0], (*axis)[1], (*axis)[2], out);
    sm_out = sm_wrap_mat4(out, self);
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_mat4_get_row3(int argc, VALUE *argv, VALUE sm_self)
{
  mat4_t *self;
  int index;
  VALUE sm_out;

  self = sm_unwrap_mat4(sm_self, NULL);
  index = NUM2INT(argv[0]);
  sm_out = Qnil;

  if (index < 0 || index > 3) {
    rb_raise(rb_eRangeError, "Index %d is out of range, must be (0 .. 3)", index);
    return Qnil;
  }

  switch (argc) {
  case 2: {
    vec3_t *out;

    sm_out = argv[1];

    if (RTEST(sm_out)) {
      SM_RAISE_IF_NOT_TYPE(sm_out, vec3);
    } else {
      goto SM_LABEL(no_output);
    }

    out = sm_unwrap_vec3(sm_out, NULL);
    mat4_get_row3(*self, index, *out);

    break;
  }

  case 1: SM_LABEL(no_output): {
    vec3_t out;
    mat4_get_row3(*self, index, out);
    sm_out = sm_wrap_vec3(out, Qnil);
    rb_obj_call_init(sm_out, 0, 0);
    break;
  }

  default: {
    rb_raise(rb_eArgError, "Invalid number of arguments to get_row3 - expected 1 or 2");
    break;
  }
  }

  return sm_out;
}



static VALUE sm_mat4_get_row4(int argc, VALUE *argv, VALUE sm_self)
{
  mat4_t *self;
  int index;
  VALUE sm_out;

  self = sm_unwrap_mat4(sm_self, NULL);
  index = NUM2INT(argv[0]);
  sm_out = Qnil;

  if (index < 0 || index > 3) {
    rb_raise(rb_eRangeError, "Index %d is out of range, must be (0 .. 3)", index);
    return Qnil;
  }

  switch (argc) {
  case 2: {
    vec4_t *out;

    sm_out = argv[1];

    if (RTEST(sm_out)) {
      SM_RAISE_IF_NOT_TYPE(sm_out, vec4);
    } else {
      goto SM_LABEL(no_output);
    }

    out = sm_unwrap_vec4(sm_out, NULL);
    mat4_get_row4(*self, index, *out);

    break;
  }

  case 1: SM_LABEL(no_output): {
    vec4_t out;
    mat4_get_row4(*self, index, out);
    sm_out = sm_wrap_vec4(out, Qnil);
    rb_obj_call_init(sm_out, 0, 0);
    break;
  }

  default: {
    rb_raise(rb_eArgError, "Invalid number of arguments to get_row4 - expected 1 or 2");
    break;
  }
  }

  return sm_out;
}



static VALUE sm_mat4_get_column3(int argc, VALUE *argv, VALUE sm_self)
{
  mat4_t *self;
  int index;
  VALUE sm_out;

  self = sm_unwrap_mat4(sm_self, NULL);
  index = NUM2INT(argv[0]);
  sm_out = Qnil;

  if (index < 0 || index > 3) {
    rb_raise(rb_eRangeError, "Index %d is out of range, must be (0 .. 3)", index);
    return Qnil;
  }

  switch (argc) {
  case 2: {
    vec3_t *out;

    sm_out = argv[1];

    if (RTEST(sm_out)) {
      SM_RAISE_IF_NOT_TYPE(sm_out, vec3);
    } else {
      goto SM_LABEL(no_output);
    }

    out = sm_unwrap_vec3(sm_out, NULL);
    mat4_get_column3(*self, index, *out);

    break;
  }

  case 1: SM_LABEL(no_output): {
    vec3_t out;
    mat4_get_column3(*self, index, out);
    sm_out = sm_wrap_vec3(out, Qnil);
    rb_obj_call_init(sm_out, 0, 0);
    break;
  }

  default: {
    rb_raise(rb_eArgError, "Invalid number of arguments to get_column3 - expected 1 or 2");
    break;
  }
  }

  return sm_out;
}



static VALUE sm_mat4_get_column4(int argc, VALUE *argv, VALUE sm_self)
{
  mat4_t *self;
  int index;
  VALUE sm_out;

  self = sm_unwrap_mat4(sm_self, NULL);
  index = NUM2INT(argv[0]);
  sm_out = Qnil;

  if (index < 0 || index > 3) {
    rb_raise(rb_eRangeError, "Index %d is out of range, must be (0 .. 3)", index);
    return Qnil;
  }

  switch (argc) {
  case 2: {
    vec4_t *out;

    sm_out = argv[1];

    if (RTEST(sm_out)) {
      SM_RAISE_IF_NOT_TYPE(sm_out, vec4);
    } else {
      goto SM_LABEL(no_output);
    }

    out = sm_unwrap_vec4(sm_out, NULL);
    mat4_get_column4(*self, index, *out);

    break;
  }

  case 1: SM_LABEL(no_output): {
    vec4_t out;
    mat4_get_column4(*self, index, out);
    sm_out = sm_wrap_vec4(out, Qnil);
    rb_obj_call_init(sm_out, 0, 0);
    break;
  }

  default: {
    rb_raise(rb_eArgError, "Invalid number of arguments to get_column4 - expected 1 or 2");
    break;
  }
  }

  return sm_out;
}



static VALUE sm_mat4_set_row3(VALUE sm_self, VALUE sm_index, VALUE sm_value)
{
  const vec3_t *value;
  int index;
  mat4_t *self;

  SM_RAISE_IF_NOT_TYPE(sm_value, vec3);

  self = sm_unwrap_mat4(sm_self, NULL);
  value = sm_unwrap_vec3(sm_value, NULL);
  index = NUM2INT(sm_index);

  if (index < 0 || index > 3) {
    rb_raise(rb_eRangeError, "Index %d is out of range, must be (0 .. 3)", index);
    return Qnil;
  }

  mat4_set_row3(index, *value, *self);

  return sm_self;
}



static VALUE sm_mat4_set_column3(VALUE sm_self, VALUE sm_index, VALUE sm_value)
{
  const vec3_t *value;
  int index;
  mat4_t *self;

  SM_RAISE_IF_NOT_TYPE(sm_value, vec3);

  self = sm_unwrap_mat4(sm_self, NULL);
  value = sm_unwrap_vec3(sm_value, NULL);
  index = NUM2INT(sm_index);

  if (index < 0 || index > 3) {
    rb_raise(rb_eRangeError, "Index %d is out of range, must be (0 .. 3)", index);
    return Qnil;
  }

  mat4_set_column3(index, *value, *self);

  return sm_self;
}



static VALUE sm_mat4_set_row4(VALUE sm_self, VALUE sm_index, VALUE sm_value)
{
  const vec4_t *value;
  int index;
  mat4_t *self;

  SM_RAISE_IF_NOT_TYPE(sm_value, vec4);

  self = sm_unwrap_mat4(sm_self, NULL);
  value = sm_unwrap_vec4(sm_value, NULL);
  index = NUM2INT(sm_index);

  if (index < 0 || index > 3) {
    rb_raise(rb_eRangeError, "Index %d is out of range, must be (0 .. 3)", index);
    return Qnil;
  }

  mat4_set_row4(index, *value, *self);

  return sm_self;
}



static VALUE sm_mat4_set_column4(VALUE sm_self, VALUE sm_index, VALUE sm_value)
{
  const vec4_t *value;
  int index;
  mat4_t *self;

  SM_RAISE_IF_NOT_TYPE(sm_value, vec4);

  self = sm_unwrap_mat4(sm_self, NULL);
  value = sm_unwrap_vec4(sm_value, NULL);
  index = NUM2INT(sm_index);

  if (index < 0 || index > 3) {
    rb_raise(rb_eRangeError, "Index %d is out of range, must be (0 .. 3)", index);
    return Qnil;
  }

  mat4_set_column4(index, *value, *self);

  return sm_self;
}



static VALUE sm_mat4_identity(VALUE sm_self)
{
  mat4_t *self = sm_unwrap_mat4(sm_self, NULL);
  mat4_identity(*self);
  return sm_self;
}



static VALUE sm_mat4_frustum(int argc, VALUE *argv, VALUE self)
{
  VALUE sm_left;
  VALUE sm_right;
  VALUE sm_bottom;
  VALUE sm_top;
  VALUE sm_z_near;
  VALUE sm_z_far;
  VALUE sm_out;
  s_float_t left;
  s_float_t right;
  s_float_t bottom;
  s_float_t top;
  s_float_t z_near;
  s_float_t z_far;

  rb_scan_args(argc, argv, "61", &sm_left, &sm_right, &sm_bottom, &sm_top, &sm_z_near, &sm_z_far, &sm_out);

  left = (s_float_t)rb_num2dbl(sm_left);
  right = (s_float_t)rb_num2dbl(sm_right);
  bottom = (s_float_t)rb_num2dbl(sm_bottom);
  top = (s_float_t)rb_num2dbl(sm_top);
  z_near = (s_float_t)rb_num2dbl(sm_z_near);
  z_far = (s_float_t)rb_num2dbl(sm_z_far);

  if (SM_IS_A(sm_out, mat4)) {
    mat4_t *out = sm_unwrap_mat4(sm_out, NULL);
    mat4_frustum(left, right, bottom, top, z_near, z_far, *out);
  } else {
    mat4_t out;
    mat4_frustum(left, right, bottom, top, z_near, z_far, out);
    sm_out = sm_wrap_mat4(out, Qnil);
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_mat4_orthographic(int argc, VALUE *argv, VALUE self)
{
  VALUE sm_left;
  VALUE sm_right;
  VALUE sm_bottom;
  VALUE sm_top;
  VALUE sm_z_near;
  VALUE sm_z_far;
  VALUE sm_out;
  s_float_t left;
  s_float_t right;
  s_float_t bottom;
  s_float_t top;
  s_float_t z_near;
  s_float_t z_far;

  rb_scan_args(argc, argv, "61", &sm_left, &sm_right, &sm_bottom, &sm_top, &sm_z_near, &sm_z_far, &sm_out);

  left = (s_float_t)rb_num2dbl(sm_left);
  right = (s_float_t)rb_num2dbl(sm_right);
  bottom = (s_float_t)rb_num2dbl(sm_bottom);
  top = (s_float_t)rb_num2dbl(sm_top);
  z_near = (s_float_t)rb_num2dbl(sm_z_near);
  z_far = (s_float_t)rb_num2dbl(sm_z_far);

  if (SM_IS_A(sm_out, mat4)) {
    mat4_t *out = sm_unwrap_mat4(sm_out, NULL);
    mat4_orthographic(left, right, bottom, top, z_near, z_far, *out);
  } else {
    mat4_t out;
    mat4_orthographic(left, right, bottom, top, z_near, z_far, out);
    sm_out = sm_wrap_mat4(out, self);
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_mat4_perspective(int argc, VALUE *argv, VALUE self)
{
  VALUE sm_fov_y;
  VALUE sm_aspect;
  VALUE sm_z_near;
  VALUE sm_z_far;
  VALUE sm_out;
  s_float_t fov_y;
  s_float_t aspect;
  s_float_t z_near;
  s_float_t z_far;

  rb_scan_args(argc, argv, "41", &sm_fov_y, &sm_aspect, &sm_z_near, &sm_z_far, &sm_out);

  fov_y = (s_float_t)rb_num2dbl(sm_fov_y);
  aspect = (s_float_t)rb_num2dbl(sm_aspect);
  z_near = (s_float_t)rb_num2dbl(sm_z_near);
  z_far = (s_float_t)rb_num2dbl(sm_z_far);

  if (SM_IS_A(sm_out, mat4)) {
    mat4_t *out = sm_unwrap_mat4(sm_out, NULL);
    mat4_perspective(fov_y, aspect, z_near, z_far, *out);
  } else {
    mat4_t out;
    mat4_perspective(fov_y, aspect, z_near, z_far, out);
    sm_out = sm_wrap_mat4(out, self);
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_mat4_look_at(int argc, VALUE *argv, VALUE self)
{
  VALUE sm_eye;
  VALUE sm_center;
  VALUE sm_up;
  VALUE sm_out;
  const vec3_t *eye;
  const vec3_t *center;
  const vec3_t *up;

  rb_scan_args(argc, argv, "31", &sm_eye, &sm_center, &sm_up, &sm_out);

  eye = sm_unwrap_vec3(sm_eye, NULL);
  center = sm_unwrap_vec3(sm_center, NULL);
  up = sm_unwrap_vec3(sm_up, NULL);

  if (SM_IS_A(sm_out, mat4)) {
    mat4_t *out = sm_unwrap_mat4(sm_out, NULL);
    mat4_look_at(*eye, *center, *up, *out);
  } else {
    mat4_t out;
    mat4_look_at(*eye, *center, *up, out);
    sm_out = sm_wrap_mat4(out, self);
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_mat4_scale(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out;
  VALUE sm_x, sm_y, sm_z;
  s_float_t x, y, z;
  mat4_t *self = sm_unwrap_mat4(sm_self, NULL);

  rb_scan_args(argc, argv, "31", &sm_x, &sm_y, &sm_z, &sm_out);
  x = rb_num2dbl(sm_x);
  y = rb_num2dbl(sm_y);
  z = rb_num2dbl(sm_z);

  if (SM_IS_A(sm_out, mat4)) {
    mat4_scale(*self, x, y, z, *sm_unwrap_mat4(sm_out, NULL));
  } else {
    mat4_t out;
    mat4_scale(*self, x, y, z, out);
    sm_out = sm_wrap_mat4(out, rb_obj_class(sm_self));
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_mat4_equals(VALUE sm_self, VALUE sm_other)
{
  if (!RTEST(sm_other)) {
    return Qfalse;
  } else {
    SM_RAISE_IF_NOT_TYPE(sm_other, mat4);
  }

  return mat4_equals(*sm_unwrap_mat4(sm_self, NULL), *sm_unwrap_mat4(sm_other, NULL)) ? Qtrue : Qfalse;
}



/*==============================================================================

  mat3_t functions

==============================================================================*/

DEF_SM_WRAP_OP(mat3);
DEF_SM_UNWRAP_OP(mat3);
DEF_SM_SIZE_OP(mat3);
DEF_SM_LENGTH_OP(mat3);
DEF_SM_FETCH_OP(mat3);
DEF_SM_STORE_OP(mat3);
DEF_SM_UNARY_OP(copy, mat3, mat3);
DEF_SM_UNARY_OP(to_mat4, mat3, mat4);
DEF_SM_UNARY_OP(transpose, mat3, mat3);
DEF_SM_UNARY_OP(adjoint, mat3, mat3);
DEF_SM_UNARY_OP(orthogonal, mat3, mat3);
DEF_SM_UNARY_OP(cofactor, mat3, mat3);
DEF_SM_BINARY_OP(multiply, mat3, mat3, mat3);
DEF_SM_BINARY_OP(rotate_vec3, mat3, vec3, vec3);
DEF_SM_BINARY_OP(inv_rotate_vec3, mat3, vec3, vec3);



static VALUE sm_mat3_determinant(VALUE sm_self)
{
  return mat3_determinant(*sm_unwrap_mat3(sm_self, NULL));
}



static VALUE sm_mat3_inverse(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out = Qnil;
  mat3_t *self;

  rb_scan_args(argc, argv, "01", &sm_out);
  self = sm_unwrap_mat3(sm_self, NULL);

  if (argc == 1) {
    mat3_t *output;

    if (!RTEST(sm_out)) {
      goto SM_LABEL(skip_output);
    }

    if (!SM_IS_A(sm_out, mat3)) {
      rb_raise(rb_eTypeError,
        "Invalid argument to output of inverse_general: expected %s, got %s",
        rb_class2name(SM_KLASS(mat3)),
        rb_obj_classname(sm_out));
      return Qnil;
    }

    output = sm_unwrap_mat3(sm_out, NULL);
    if (!mat3_inverse(*self, *output)) {
      return Qnil;
    }

  } else if (argc == 0) {
    SM_LABEL(skip_output): {
      mat3_t output;
      if (!mat3_inverse(*self, output)) {
        return Qnil;
      }

      sm_out = sm_wrap_mat3(output, rb_obj_class(sm_self));
      rb_obj_call_init(sm_out, 0, 0);
    }
  } else {
    rb_raise(rb_eArgError, "Invalid number of arguments to inverse");
  }

  return sm_out;
}



static VALUE sm_mat3_new(int argc, VALUE *argv, VALUE self)
{
  VALUE sm_mat = sm_wrap_mat3(g_mat3_identity, self);
  rb_obj_call_init(sm_mat, argc, argv);
  return sm_mat;
}



static VALUE sm_mat3_init(int argc, VALUE *argv, VALUE sm_self)
{
  mat3_t *self = sm_unwrap_mat3(sm_self, NULL);
  size_t arr_index = 0;

  switch (argc) {

  case 0: {
    // Identity (handled in _new)
    break;
  }

  // Copy Mat3 or provided [Numeric..]
  case 1: {
    // Copy Mat3
    if (SM_IS_A(argv[0], mat3)) {
      sm_unwrap_mat3(argv[0], *self);
      break;
    }

    // Copy Mat4
    if (SM_IS_A(argv[0], mat4)) {
      mat4_to_mat3(*sm_unwrap_mat4(argv[0], NULL), *self);
      break;
    }

    // Build from Quaternion
    if (SM_IS_A(argv[0], quat)) {
      mat3_from_quat(*sm_unwrap_quat(argv[0], NULL), *self);
      break;
    }

    // Optional offset into array provided
    if (0) {
      case 2:
      arr_index = NUM2SIZET(argv[1]);
    }

    // Array of values
    if (SM_RB_IS_A(argv[0], rb_cArray)) {
      VALUE arrdata = argv[0];
      const size_t arr_end = arr_index + 9;
      s_float_t *mat_elem = *self;
      for (; arr_index < arr_end; ++arr_index, ++mat_elem) {
        *mat_elem = rb_num2dbl(rb_ary_entry(arrdata, (long)arr_index));
      }
      break;
    }

    rb_raise(rb_eArgError, "Expected either an array of Numerics or a Mat3");
    break;
  }

  // Mat3(Vec3, Vec3, Vec3)
  case 3: {
    size_t arg_index;
    s_float_t *mat_elem = *self;
    for (arg_index = 0; arg_index < 3; ++arg_index, mat_elem += 3) {
      if (!SM_IS_A(argv[arg_index], vec3)) {
        rb_raise(
          rb_eArgError,
          "Argument %d must be a Vec3 when supplying three arguments to Mat3.initialize",
          (int)(arg_index + 1));
      }

      sm_unwrap_vec3(argv[arg_index], mat_elem);
    }
    break;
  }

  // Mat3(Numeric m00 .. m16)
  case 9: {
    s_float_t *mat_elem = *self;
    VALUE *argv_p = argv;
    for (; argc; --argc, ++argv_p, ++mat_elem) {
      *mat_elem = (s_float_t)rb_num2dbl(*argv_p);
    }
    break;
  }

  default: {
    rb_raise(rb_eArgError, "Invalid arguments to Mat3.initialize");
    break;
  }
  } // swtich (argc)

  return sm_self;
}



static VALUE sm_mat3_to_s(VALUE self)
{
  const s_float_t *v;
  v = (const s_float_t *)*sm_unwrap_mat3(self, NULL);
  return rb_sprintf(
    "{ "
    "%f, %f, %f" ",\n  "
    "%f, %f, %f" ",\n  "
    "%f, %f, %f"
    " }",
    v[0],   v[1],   v[2],
    v[3],   v[4],   v[5],
    v[6],   v[7],   v[8] );
}



static VALUE sm_mat3_angle_axis(int argc, VALUE *argv, VALUE self)
{
  VALUE sm_angle;
  VALUE sm_axis;
  VALUE sm_out;
  s_float_t angle;
  const vec3_t *axis;

  rb_scan_args(argc, argv, "21", &sm_angle, &sm_axis, &sm_out);
  SM_RAISE_IF_NOT_TYPE(sm_axis, vec3);

  angle = (s_float_t)rb_num2dbl(sm_angle);
  axis = sm_unwrap_vec3(sm_axis, NULL);

  if (SM_IS_A(sm_out, mat3)) {
    mat3_t *out = sm_unwrap_mat3(sm_out, NULL);
    mat3_rotation(angle, (*axis)[0], (*axis)[1], (*axis)[2], *out);
  } else {
    mat3_t out;
    mat3_rotation(angle, (*axis)[0], (*axis)[1], (*axis)[2], out);
    sm_out = sm_wrap_mat3(out, self);
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_mat3_get_row3(int argc, VALUE *argv, VALUE sm_self)
{
  mat3_t *self;
  int index;
  VALUE sm_out;

  self = sm_unwrap_mat3(sm_self, NULL);
  index = NUM2INT(argv[0]);
  sm_out = Qnil;

  if (index < 0 || index > 2) {
    rb_raise(rb_eRangeError, "Index %d is out of range, must be (0 .. 2)", index);
    return Qnil;
  }

  switch (argc) {
  case 2: {
    vec3_t *out;

    sm_out = argv[1];

    if (RTEST(sm_out)) {
      SM_RAISE_IF_NOT_TYPE(sm_out, vec3);
    } else {
      goto SM_LABEL(no_output);
    }

    out = sm_unwrap_vec3(sm_out, NULL);
    mat3_get_row3(*self, index, *out);

    break;
  }

  case 1: SM_LABEL(no_output): {
    vec3_t out;
    mat3_get_row3(*self, index, out);
    sm_out = sm_wrap_vec3(out, Qnil);
    rb_obj_call_init(sm_out, 0, 0);
    break;
  }

  default: {
    rb_raise(rb_eArgError, "Invalid number of arguments to get_row3 - expected 1 or 2");
    break;
  }
  }

  return sm_out;
}



static VALUE sm_mat3_get_column3(int argc, VALUE *argv, VALUE sm_self)
{
  mat3_t *self;
  int index;
  VALUE sm_out;

  self = sm_unwrap_mat3(sm_self, NULL);
  index = NUM2INT(argv[0]);
  sm_out = Qnil;

  if (index < 0 || index > 2) {
    rb_raise(rb_eRangeError, "Index %d is out of range, must be (0 .. 2)", index);
    return Qnil;
  }

  switch (argc) {
  case 2: {
    vec3_t *out;

    sm_out = argv[1];

    if (RTEST(sm_out)) {
      SM_RAISE_IF_NOT_TYPE(sm_out, vec3);
    } else {
      goto SM_LABEL(no_output);
    }

    out = sm_unwrap_vec3(sm_out, NULL);
    mat3_get_column3(*self, index, *out);

    break;
  }

  case 1: SM_LABEL(no_output): {
    vec3_t out;
    mat3_get_column3(*self, index, out);
    sm_out = sm_wrap_vec3(out, Qnil);
    rb_obj_call_init(sm_out, 0, 0);
    break;
  }

  default: {
    rb_raise(rb_eArgError, "Invalid number of arguments to get_column3 - expected 1 or 2");
    break;
  }
  }

  return sm_out;
}



static VALUE sm_mat3_set_row3(VALUE sm_self, VALUE sm_index, VALUE sm_value)
{
  const vec3_t *value;
  int index;
  mat3_t *self;

  SM_RAISE_IF_NOT_TYPE(sm_value, vec3);

  self = sm_unwrap_mat3(sm_self, NULL);
  value = sm_unwrap_vec3(sm_value, NULL);
  index = NUM2INT(sm_index);

  if (index < 0 || index > 2) {
    rb_raise(rb_eRangeError, "Index %d is out of range, must be (0 .. 2)", index);
    return Qnil;
  }

  mat3_set_row3(index, *value, *self);

  return sm_self;
}



static VALUE sm_mat3_set_column3(VALUE sm_self, VALUE sm_index, VALUE sm_value)
{
  const vec3_t *value;
  int index;
  mat3_t *self;

  SM_RAISE_IF_NOT_TYPE(sm_value, vec3);

  self = sm_unwrap_mat3(sm_self, NULL);
  value = sm_unwrap_vec3(sm_value, NULL);
  index = NUM2INT(sm_index);

  if (index < 0 || index > 2) {
    rb_raise(rb_eRangeError, "Index %d is out of range, must be (0 .. 2)", index);
    return Qnil;
  }

  mat3_set_column3(index, *value, *self);

  return sm_self;
}



static VALUE sm_mat3_identity(VALUE sm_self)
{
  mat3_t *self = sm_unwrap_mat3(sm_self, NULL);
  mat3_identity(*self);
  return sm_self;
}



static VALUE sm_mat3_scale(int argc, VALUE *argv, VALUE sm_self)
{
  VALUE sm_out;
  VALUE sm_x, sm_y, sm_z;
  s_float_t x, y, z;
  mat3_t *self = sm_unwrap_mat3(sm_self, NULL);

  rb_scan_args(argc, argv, "31", &sm_x, &sm_y, &sm_z, &sm_out);
  x = rb_num2dbl(sm_x);
  y = rb_num2dbl(sm_y);
  z = rb_num2dbl(sm_z);

  if (SM_IS_A(sm_out, mat3)) {
    mat3_scale(*self, x, y, z, *sm_unwrap_mat3(sm_out, NULL));
  } else {
    mat3_t out;
    mat3_scale(*self, x, y, z, out);
    sm_out = sm_wrap_mat3(out, rb_obj_class(sm_self));
    rb_obj_call_init(sm_out, 0, 0);
  }

  return sm_out;
}



static VALUE sm_mat3_equals(VALUE sm_self, VALUE sm_other)
{
  if (!RTEST(sm_other)) {
    return Qfalse;
  } else {
    SM_RAISE_IF_NOT_TYPE(sm_other, mat3);
  }

  return mat3_equals(*sm_unwrap_mat3(sm_self, NULL), *sm_unwrap_mat3(sm_other, NULL)) ? Qtrue : Qfalse;
}



/*==============================================================================

  General-purpose functions

==============================================================================*/

static VALUE sm_get_address(VALUE sm_self)
{
  void *data_ptr = NULL;
  Data_Get_Struct(sm_self, void, data_ptr);
  return ULL2NUM((unsigned long long)data_ptr);
}



void Init_bindings()
{
  kRB_IVAR_MATHARRAY_LENGTH = rb_intern("__length");
  kRB_IVAR_MATHARRAY_SOURCE = rb_intern("__source");

  s_sm_snowmath_mod         = rb_define_module("Snow");
  SM_KLASS(vec3)            = rb_define_class_under(s_sm_snowmath_mod, "Vec3", rb_cObject);
  SM_KLASS(vec4)            = rb_define_class_under(s_sm_snowmath_mod, "Vec4", rb_cObject);
  SM_KLASS(quat)            = rb_define_class_under(s_sm_snowmath_mod, "Quat", rb_cObject);
  SM_KLASS(mat3)            = rb_define_class_under(s_sm_snowmath_mod, "Mat3", rb_cObject);
  SM_KLASS(mat4)            = rb_define_class_under(s_sm_snowmath_mod, "Mat4", rb_cObject);

  rb_define_singleton_method(SM_KLASS(vec3), "new", sm_vec3_new, -1);
  rb_define_method(SM_KLASS(vec3), "initialize", sm_vec3_init, -1);
  rb_define_method(SM_KLASS(vec3), "set", sm_vec3_init, -1);
  rb_define_method(SM_KLASS(vec3), "fetch", sm_vec3_fetch, 1);
  rb_define_method(SM_KLASS(vec3), "store", sm_vec3_store, 2);
  rb_define_method(SM_KLASS(vec3), "size", sm_vec3_size, 0);
  rb_define_method(SM_KLASS(vec3), "length", sm_vec3_length, 0);
  rb_define_method(SM_KLASS(vec3), "to_s", sm_vec3_to_s, 0);
  rb_define_method(SM_KLASS(vec3), "address", sm_get_address, 0);
  rb_define_method(SM_KLASS(vec3), "copy", sm_vec3_copy, -1);
  rb_define_method(SM_KLASS(vec3), "normalize", sm_vec3_normalize, -1);
  rb_define_method(SM_KLASS(vec3), "inverse", sm_vec3_inverse, -1);
  rb_define_method(SM_KLASS(vec3), "negate", sm_vec3_negate, -1);
  rb_define_method(SM_KLASS(vec3), "cross_product", sm_vec3_cross_product, -1);
  rb_define_method(SM_KLASS(vec3), "multiply_vec3", sm_vec3_multiply, -1);
  rb_define_method(SM_KLASS(vec3), "add", sm_vec3_add, -1);
  rb_define_method(SM_KLASS(vec3), "subtract", sm_vec3_subtract, -1);
  rb_define_method(SM_KLASS(vec3), "reflect", sm_vec3_reflect, -1);
  rb_define_method(SM_KLASS(vec3), "project", sm_vec3_project, -1);
  rb_define_method(SM_KLASS(vec3), "dot_product", sm_vec3_dot_product, 1);
  rb_define_method(SM_KLASS(vec3), "magnitude_squared", sm_vec3_magnitude_squared, 0);
  rb_define_method(SM_KLASS(vec3), "magnitude", sm_vec3_magnitude, 0);
  rb_define_method(SM_KLASS(vec3), "scale", sm_vec3_scale, -1);
  rb_define_method(SM_KLASS(vec3), "divide", sm_vec3_divide, -1);
  rb_define_method(SM_KLASS(vec3), "==", sm_vec3_equals, 1);

  rb_define_singleton_method(SM_KLASS(vec4), "new", sm_vec4_new, -1);
  rb_define_method(SM_KLASS(vec4), "initialize", sm_vec4_init, -1);
  rb_define_method(SM_KLASS(vec4), "set", sm_vec4_init, -1);
  rb_define_method(SM_KLASS(vec4), "fetch", sm_vec4_fetch, 1);
  rb_define_method(SM_KLASS(vec4), "store", sm_vec4_store, 2);
  rb_define_method(SM_KLASS(vec4), "size", sm_vec4_size, 0);
  rb_define_method(SM_KLASS(vec4), "length", sm_vec4_length, 0);
  rb_define_method(SM_KLASS(vec4), "to_s", sm_vec4_to_s, 0);
  rb_define_method(SM_KLASS(vec4), "address", sm_get_address, 0);
  rb_define_method(SM_KLASS(vec4), "copy", sm_vec4_copy, -1);
  rb_define_method(SM_KLASS(vec4), "normalize", sm_vec4_normalize, -1);
  rb_define_method(SM_KLASS(vec4), "inverse", sm_vec4_inverse, -1);
  rb_define_method(SM_KLASS(vec4), "negate", sm_vec4_negate, -1);
  rb_define_method(SM_KLASS(vec4), "multiply_vec4", sm_vec4_multiply, -1);
  rb_define_method(SM_KLASS(vec4), "add", sm_vec4_add, -1);
  rb_define_method(SM_KLASS(vec4), "subtract", sm_vec4_subtract, -1);
  rb_define_method(SM_KLASS(vec4), "reflect", sm_vec4_reflect, -1);
  rb_define_method(SM_KLASS(vec4), "project", sm_vec4_project, -1);
  rb_define_method(SM_KLASS(vec4), "dot_product", sm_vec4_dot_product, 1);
  rb_define_method(SM_KLASS(vec4), "magnitude_squared", sm_vec4_magnitude_squared, 0);
  rb_define_method(SM_KLASS(vec4), "magnitude", sm_vec4_magnitude, 0);
  rb_define_method(SM_KLASS(vec4), "scale", sm_vec4_scale, -1);
  rb_define_method(SM_KLASS(vec4), "divide", sm_vec4_divide, -1);
  rb_define_method(SM_KLASS(vec4), "==", sm_vec4_equals, 1);

  rb_define_singleton_method(SM_KLASS(quat), "new", sm_quat_new, -1);
  rb_define_singleton_method(SM_KLASS(quat), "angle_axis", sm_quat_angle_axis, -1);
  rb_define_method(SM_KLASS(quat), "initialize", sm_quat_init, -1);
  rb_define_method(SM_KLASS(quat), "set", sm_quat_init, -1);
  rb_define_method(SM_KLASS(quat), "load_identity", sm_quat_identity, 0);
  rb_define_method(SM_KLASS(quat), "fetch", sm_quat_fetch, 1);
  rb_define_method(SM_KLASS(quat), "store", sm_quat_store, 2);
  rb_define_method(SM_KLASS(quat), "size", sm_quat_size, 0);
  rb_define_method(SM_KLASS(quat), "length", sm_quat_length, 0);
  rb_define_method(SM_KLASS(quat), "to_s", sm_quat_to_s, 0);
  rb_define_method(SM_KLASS(quat), "address", sm_get_address, 0);
  rb_define_method(SM_KLASS(quat), "copy", sm_quat_copy, -1);
  rb_define_method(SM_KLASS(quat), "inverse", sm_quat_inverse, -1);
  rb_define_method(SM_KLASS(quat), "negate", sm_quat_negate, -1);
  rb_define_method(SM_KLASS(quat), "multiply_quat", sm_quat_multiply, -1);
  rb_define_method(SM_KLASS(quat), "multiply_vec3", sm_quat_multiply_vec3, -1);
  rb_define_method(SM_KLASS(quat), "normalize", sm_quat_normalize, -1);
  rb_define_method(SM_KLASS(quat), "scale", sm_quat_scale, -1);
  rb_define_method(SM_KLASS(quat), "divide", sm_quat_divide, -1);
  rb_define_method(SM_KLASS(quat), "add", sm_quat_add, -1);
  rb_define_method(SM_KLASS(quat), "subtract", sm_quat_subtract, -1);
  rb_define_method(SM_KLASS(quat), "slerp", sm_quat_slerp, -1);
  // Borrow some functions from vec4
  rb_define_method(SM_KLASS(quat), "dot_product", sm_vec4_dot_product, 1);
  rb_define_method(SM_KLASS(quat), "magnitude_squared", sm_vec4_magnitude_squared, 0);
  rb_define_method(SM_KLASS(quat), "magnitude", sm_vec4_magnitude, 0);
  rb_define_method(SM_KLASS(quat), "==", sm_vec4_equals, 1);

  rb_define_singleton_method(SM_KLASS(mat4), "new", sm_mat4_new, -1);
  rb_define_singleton_method(SM_KLASS(mat4), "translation", sm_mat4_translation, -1);
  rb_define_singleton_method(SM_KLASS(mat4), "angle_axis", sm_mat4_angle_axis, -1);
  rb_define_singleton_method(SM_KLASS(mat4), "frustum", sm_mat4_frustum, -1);
  rb_define_singleton_method(SM_KLASS(mat4), "perspective", sm_mat4_perspective, -1);
  rb_define_singleton_method(SM_KLASS(mat4), "orthographic", sm_mat4_orthographic, -1);
  rb_define_singleton_method(SM_KLASS(mat4), "look_at", sm_mat4_look_at, -1);
  rb_define_method(SM_KLASS(mat4), "initialize", sm_mat4_init, -1);
  rb_define_method(SM_KLASS(mat4), "set", sm_mat4_init, -1);
  rb_define_method(SM_KLASS(mat4), "to_mat3", sm_mat4_to_mat3, -1);
  rb_define_method(SM_KLASS(mat4), "load_identity", sm_mat4_identity, 0);
  rb_define_method(SM_KLASS(mat4), "fetch", sm_mat4_fetch, 1);
  rb_define_method(SM_KLASS(mat4), "store", sm_mat4_store, 2);
  rb_define_method(SM_KLASS(mat4), "size", sm_mat4_size, 0);
  rb_define_method(SM_KLASS(mat4), "length", sm_mat4_length, 0);
  rb_define_method(SM_KLASS(mat4), "to_s", sm_mat4_to_s, 0);
  rb_define_method(SM_KLASS(mat4), "address", sm_get_address, 0);
  rb_define_method(SM_KLASS(mat4), "copy", sm_mat4_copy, -1);
  rb_define_method(SM_KLASS(mat4), "transpose", sm_mat4_transpose, -1);
  rb_define_method(SM_KLASS(mat4), "inverse_orthogonal", sm_mat4_inverse_orthogonal, -1);
  rb_define_method(SM_KLASS(mat4), "adjoint", sm_mat4_adjoint, -1);
  rb_define_method(SM_KLASS(mat4), "scale", sm_mat4_scale, -1);
  rb_define_method(SM_KLASS(mat4), "multiply_mat4", sm_mat4_multiply, -1);
  rb_define_method(SM_KLASS(mat4), "multiply_vec4", sm_mat4_multiply_vec4, -1);
  rb_define_method(SM_KLASS(mat4), "transform_vec3", sm_mat4_transform_vec3, -1);
  rb_define_method(SM_KLASS(mat4), "rotate_vec3", sm_mat4_rotate_vec3, -1);
  rb_define_method(SM_KLASS(mat4), "inverse_rotate_vec3", sm_mat4_inv_rotate_vec3, -1);
  rb_define_method(SM_KLASS(mat4), "inverse_affine", sm_mat4_inverse_affine, -1);
  rb_define_method(SM_KLASS(mat4), "inverse_general", sm_mat4_inverse_general, -1);
  rb_define_method(SM_KLASS(mat4), "determinant", sm_mat4_determinant, 0);
  rb_define_method(SM_KLASS(mat4), "translate", sm_mat4_translate, -1);
  rb_define_method(SM_KLASS(mat4), "set_row3", sm_mat4_set_row3, 2);
  rb_define_method(SM_KLASS(mat4), "set_row4", sm_mat4_set_row4, 2);
  rb_define_method(SM_KLASS(mat4), "get_row3", sm_mat4_get_row3, -1);
  rb_define_method(SM_KLASS(mat4), "get_row4", sm_mat4_get_row4, -1);
  rb_define_method(SM_KLASS(mat4), "set_column3", sm_mat4_set_column3, 2);
  rb_define_method(SM_KLASS(mat4), "set_column4", sm_mat4_set_column4, 2);
  rb_define_method(SM_KLASS(mat4), "get_column3", sm_mat4_get_column3, -1);
  rb_define_method(SM_KLASS(mat4), "get_column4", sm_mat4_get_column4, -1);
  rb_define_method(SM_KLASS(mat4), "==", sm_mat4_equals, 1);

  rb_define_singleton_method(SM_KLASS(mat3), "new", sm_mat3_new, -1);
  rb_define_singleton_method(SM_KLASS(mat3), "angle_axis", sm_mat3_angle_axis, -1);
  rb_define_method(SM_KLASS(mat3), "initialize", sm_mat3_init, -1);
  rb_define_method(SM_KLASS(mat3), "set", sm_mat3_init, -1);
  rb_define_method(SM_KLASS(mat3), "to_mat4", sm_mat3_to_mat4, -1);
  rb_define_method(SM_KLASS(mat3), "load_identity", sm_mat3_identity, 0);
  rb_define_method(SM_KLASS(mat3), "fetch", sm_mat3_fetch, 1);
  rb_define_method(SM_KLASS(mat3), "store", sm_mat3_store, 2);
  rb_define_method(SM_KLASS(mat3), "size", sm_mat3_size, 0);
  rb_define_method(SM_KLASS(mat3), "length", sm_mat3_length, 0);
  rb_define_method(SM_KLASS(mat3), "to_s", sm_mat3_to_s, 0);
  rb_define_method(SM_KLASS(mat3), "address", sm_get_address, 0);
  rb_define_method(SM_KLASS(mat3), "copy", sm_mat3_copy, -1);
  rb_define_method(SM_KLASS(mat3), "transpose", sm_mat3_transpose, -1);
  rb_define_method(SM_KLASS(mat3), "adjoint", sm_mat3_adjoint, -1);
  rb_define_method(SM_KLASS(mat3), "cofactor", sm_mat3_cofactor, -1);
  rb_define_method(SM_KLASS(mat3), "orthogonal", sm_mat3_orthogonal, -1);
  rb_define_method(SM_KLASS(mat3), "scale", sm_mat3_scale, -1);
  rb_define_method(SM_KLASS(mat3), "multiply_mat3", sm_mat3_multiply, -1);
  rb_define_method(SM_KLASS(mat3), "rotate_vec3", sm_mat3_rotate_vec3, -1);
  rb_define_method(SM_KLASS(mat3), "inverse_rotate_vec3", sm_mat3_inv_rotate_vec3, -1);
  rb_define_method(SM_KLASS(mat3), "inverse", sm_mat3_inverse, -1);
  rb_define_method(SM_KLASS(mat3), "determinant", sm_mat3_determinant, 0);
  rb_define_method(SM_KLASS(mat3), "set_row3", sm_mat3_set_row3, 2);
  rb_define_method(SM_KLASS(mat3), "get_row3", sm_mat3_get_row3, -1);
  rb_define_method(SM_KLASS(mat3), "set_column3", sm_mat3_set_column3, 2);
  rb_define_method(SM_KLASS(mat3), "get_column3", sm_mat3_get_column3, -1);
  rb_define_method(SM_KLASS(mat3), "==", sm_mat3_equals, 1);

  #ifdef BUILD_ARRAY_TYPE
  REG_SM_ARR_TYPE(vec3, "Vec3Array");
  REG_SM_ARR_TYPE(vec4, "Vec4Array");
  REG_SM_ARR_TYPE(quat, "QuatArray");
  REG_SM_ARR_TYPE(mat3, "Mat3Array");
  REG_SM_ARR_TYPE(mat4, "Mat4Array");
  #endif

}
